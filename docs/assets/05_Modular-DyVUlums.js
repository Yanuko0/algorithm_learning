import{j as e}from"./index-TyprLMAk.js";import{n as l}from"./node_img-6ZY88qdo.js";/* empty css                           */import{I as s}from"./index-Da_GFosw.js";const a=()=>e.jsxs("div",{className:"full_page",children:[e.jsx("div",{className:"title",children:"模塊化"}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"模塊化"}),e.jsx("p",{children:"模塊化是指解決了一個複雜問題時,自頂向下逐層把系統分成若干模塊的過程。對於整個系統來說,模塊是可組合、分解和更換的單元。"}),e.jsxs("p",{children:[e.jsx("ul",{children:e.jsx("li",{children:"編成領域中的模塊化"})}),"遵守固定的規則,把一個大文件拆成獨立且互相依賴的多個小模塊。"]}),e.jsxs("p",{children:["把代碼進行模塊化拆分的好處:",e.jsxs("ul",{children:[e.jsx("li",{children:"提高代碼的複用性"}),e.jsx("li",{children:"提高代碼的可維護性"}),e.jsx("li",{children:"實現按需加載"})]})]})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"模塊化規範"}),e.jsx("p",{children:"對代碼進行模塊化的拆分與組合時,需要遵守的那些規則。"}),e.jsxs("p",{children:["例如:",e.jsxs("ul",{children:[e.jsx("li",{children:"使用什麼樣的語法格式來引入別的模塊"}),e.jsx("li",{children:"在模塊中使用什麼樣的語法格式,向外暴露成員"})]})]}),e.jsx("p",{children:"模塊化規範的好處: 大家都遵守同樣的模塊化規範寫代碼, 降低了溝通的成本,極大方便各模塊之間的互相調用,利人利己。"})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"Node.js模塊化分類"}),e.jsx("p",{children:"node.js中根據模塊來源的不同,將模塊分為了三大類,分別是:"}),e.jsxs("ul",{children:[e.jsx("li",{children:"內置模塊(內置模塊是由Node.js官方提供的,例如fs、path、http等)"}),e.jsx("li",{children:"自定義模塊(用戶創建的每個.js文件,都是自定義模塊)"}),e.jsx("li",{children:"第三方模塊(由第三方開發出來的模塊,並非官方提供的內置模塊,也不是用戶創建的自定義模塊,使用前須要先下載)"})]})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"加載模塊"}),e.jsx("p",{children:"使用強大的require()方法,可以加載需要的內置模塊、用戶自定義模塊、第三方模塊進行使用。例如:"}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_01,alt:"模塊化_01"})})})}),"注意:使用require()方法加載其他模塊時,會執行倍加載模塊中的代碼。"]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"Node.js模塊作用域"}),e.jsxs("p",{children:[e.jsx("ul",{children:e.jsx("li",{children:"1.什麼是模塊作用域"})}),"和函數作用域類似, 在自定義模塊中定義的變量、方法等成員,只能在當前模塊內被訪問,這種模塊級別的訪問限制,叫做模塊作用域。"]}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_02,alt:"模塊化_02"})})})})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"模塊作用域的好處"}),e.jsx("p",{children:e.jsx("ul",{children:e.jsx("li",{children:"防止全局變量污染的問題"})})}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_03,alt:"模塊化_03"})})})})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"module對象"}),e.jsx("p",{children:"在每個.js自定義模塊中都有一個module對象,它裡面存儲了當前模塊有關的信息"}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_04,alt:"模塊化_04"})})})}),e.jsx("p",{children:"在自定義模塊中, 可以使用module.exports對象,將模塊內的成員共享出去,供外界使用。 外界用 require()方法,導入自定義模塊時,得到的就是module.exports所指向的對象。"}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_05,alt:"模塊化_05"})})})})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"向外共享成員時的注意點"}),e.jsx("p",{children:"使用require()方法導入模塊時, 導入的結果,永遠以module.exports指向的對象為準"}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_06,alt:"模塊化_06"})})})})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"exports對象"}),e.jsx("p",{children:"由於module.exports單詞寫起來比較複雜,為了簡化向外共享成員的代碼,Node提供了exports對象。默認情況下,exports和module.exports指向同一對象。最終共享的結果,還是以module.exports指向的對象為準。"}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.模塊化_07,alt:"模塊化_07"})})})})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"1.exports和module.exports的使用誤區"}),e.jsx("p",{children:"時刻謹記,requires()模塊時,得到的永遠是module.exports指向的對象"}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.exports_01,alt:"exports_01"})})})}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.exports_02,alt:"exports_02"})})})}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.exports_03,alt:"exports_03"})})})}),e.jsx("p",{className:"diagram",children:e.jsx("div",{className:"commentaryBox",children:e.jsx(s.PreviewGroup,{preview:{onChange:(r,i)=>console.log(`current index: ${r}, prev index: ${i}`)},children:e.jsx(s,{src:l.exports_04,alt:"exports_04"})})})})]})}),e.jsx("div",{className:"introduce",children:e.jsxs("div",{className:"diagrambox",children:[e.jsx("p",{children:"模塊化規範"}),e.jsx("p",{children:"Node.js 遵循了CommonJS模塊化規範, CommonJS規定了模塊的特性和各模塊之間如何相互依賴。"}),e.jsx("p",{children:"CommonJS 規定"}),e.jsx("p",{children:e.jsxs("ul",{children:[e.jsx("li",{children:"每個模塊內部, module變量代表當前模塊。"}),e.jsx("li",{children:"module變量是一個對象,它的exports屬性(即module.exports)是對外的接口。"}),e.jsx("li",{children:"加載某個模塊,其實是加載該模塊的module.exports屬性。 require()方法用於加載模塊"})]})})]})})]});export{a as default};
